# -*- coding: utf-8 -*-
"""Ejercicio17_18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JvdsGvzGYG_tcHokRnWMXyCHNMp86qDk
"""

def encode_base64(text):
    # Tabla de caracteres Base64
    base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

    # Convertir texto a una secuencia de bytes
    bytes_text = text.encode()

    # Codificar los bytes en Base64
    result = ""
    for i in range(0, len(bytes_text), 3):
        chunk = bytes_text[i:i+3]
        # Rellenar con ceros si el tamaño no es múltiplo de 3
        if len(chunk) < 3:
            chunk += b'\x00' * (3 - len(chunk))
        # Obtener valores ASCII de los bytes
        values = [byte for byte in chunk]
        # Obtener índices en la tabla Base64
        index1 = (values[0] & 0xfc) >> 2
        index2 = ((values[0] & 0x03) << 4) | ((values[1] & 0xf0) >> 4)
        index3 = ((values[1] & 0x0f) << 2) | ((values[2] & 0xc0) >> 6)
        index4 = values[2] & 0x3f
        # Convertir índices a caracteres Base64
        result += base64_chars[index1] + base64_chars[index2] + base64_chars[index3] + base64_chars[index4]

    # Reemplazar el último caracter con '=' si la longitud no es un múltiplo de 3
    if len(bytes_text) % 3 == 1:
        result = result[:-2] + "=="
    elif len(bytes_text) % 3 == 2:
        result = result[:-1] + "="

    return result

def decode_base64(encoded_text):
    # Tabla de caracteres Base64
    base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

    # Convertir texto codificado a una secuencia de bytes
    bytes_text = bytearray()
    for char in encoded_text:
        if char == '=':
            break
        bytes_text.append(base64_chars.index(char))

    # Decodificar los bytes desde Base64
    result = bytearray()
    for i in range(0, len(bytes_text), 4):
        chunk = bytes_text[i:i+4]
        # Obtener valores binarios de los caracteres Base64
        values = [byte for byte in chunk]
        # Asegurarse de que haya suficientes valores para la decodificación
        if len(values) >= 3:
            # Calcular valores de bytes decodificados
            byte1 = (values[0] << 2) | (values[1] >> 4)
            byte2 = ((values[1] & 0x0f) << 4) | ((values[2] & 0x3c) >> 2)
            byte3 = ((values[2] & 0x03) << 6) | (values[3] if len(values) > 3 else 0)
            # Agregar bytes decodificados al resultado
            result.extend([byte1, byte2, byte3])

    # Eliminar bytes de relleno
    if encoded_text[-1] == '=':
        result.pop()
        if encoded_text[-2] == '=':
            result.pop()

    return bytes(result).decode()

text_to_encode = "Hello, World!"
encoded_text = encode_base64(text_to_encode)
print("Texto codificado:", encoded_text)
decoded_text = decode_base64(encoded_text)
print("Texto decodificado:", decoded_text)



Ejercicios adicionales

    Modifica las funciones para admitir una tabla de caracteres Base64 personalizada que incluya caracteres adicionales o excluya algunos de los caracteres estándar.
    Actualiza la función de decodificación para admitir texto codificado en Base64 con o sin caracteres de relleno ('=') al final.
    Modifica las funciones para manejar correctamente el texto Unicode, asegurándote de que la codificación y decodificación se realicen correctamente para cualquier tipo de texto.
    Encuentra formas de optimizar el rendimiento de las funciones de codificación y decodificación, especialmente para textos largos o grandes volúmenes de datos.
    Intenta implementar otras codificaciones de texto, como Base32 o Base16, siguiendo un enfoque similar al de Base64.
    Agrega validación de entrada en las funciones para asegurarte de que solo se proporcionen datos válidos para codificación o decodificación.
    Crea funciones adicionales para codificar y decodificar archivos binarios en Base64, permitiendo la conversión de archivos a y desde texto Base64.
    Explora cómo podrías integrar la codificación Base64 con otros algoritmos de cifrado o compresión para crear un sistema más completo de procesamiento de datos.
    Escribe pruebas unitarias exhaustivas para verificar la precisión y robustez de las funciones de codificación y decodificación en una variedad de casos de prueba.
    Crea una interfaz de usuario simple que permita a los usuarios ingresar texto y ver el resultado de la codificación y decodificación Base64 en tiempo real.

import base64
def base64_encode(texto: str) -> str:
    return base64.b64encode(texto.encode('utf-7')).decode('utf-7')
def base64_decode(texto_codificado: str) -> str:
    return base64.b64decode(texto_codificado).decode('utf-7')
Frase = "Hello, World"
Frase_codificado = base64_encode(phrase)
print(f"Encoded phrase: {Frase_codificado}")
Frase_decodificado = base64_decode(Frase_codificado)
print(f"Decoded phrase: {Frase_decodificado}")



import time
def simulate_dos_attack(request_rate_threshold, duration, service_capacity):
    """
    Simula un ataque de denegación de servicio (DoS) a un servicio de red.

    Args:
    - request_rate_threshold: Umbral de tasa de solicitudes para considerar el servicio sobrecargado.
    - duration: Duración del ataque (en segundos).
    - service_capacity: Capacidad máxima del servicio para manejar solicitudes.

    Returns:
    - overload_start_time: Tiempo en el que el servicio se considera sobrecargado.
    """
    start_time = time.time() - 0.001  # Establecer start_time ligeramente antes del inicio del bucle
    current_time = start_time
    request_count = 0

    while current_time - start_time < duration:
        # Simula la llegada de una solicitud
        request_count += 1

        # Verifica si el servicio está sobrecargado
        if current_time - start_time != 0 and request_count / (current_time - start_time) > request_rate_threshold:
            overload_start_time = current_time
            return overload_start_time

        # Simula el procesamiento de la solicitud
        time.sleep(0.001)

        # Actualiza el tiempo actual
        current_time = time.time()

    # Si no se supera el umbral durante la duración especificada, el servicio no se considera sobrecargado
    return None

# Ejemplo de uso
request_rate_threshold = 100  # Umbral de 100 solicitudes por segundo
duration = 10  # Duración del ataque en segundos
service_capacity = 500  # Capacidad máxima del servicio para manejar solicitudes

overload_start_time = simulate_dos_attack(request_rate_threshold, duration, service_capacity)
if overload_start_time:
    print(f"El servicio está sobrecargado a partir de {overload_start_time}")
else:
    print("El servicio no está sobrecargado durante el ataque.")

Ejercicios adicionales

    Modifica el código para que las solicitudes se manejen en una cola en lugar de procesarse una a la vez. Esto puede proporcionar una representación más realista de cómo se manejarían las solicitudes en un entorno de producción.

    Modifica el código para que el servicio tenga una capacidad máxima definida y rechace las solicitudes adicionales una vez que se alcance esa capacidad. Puedes usar una estructura de datos como una cola para almacenar las solicitudes en espera y rechazarlas si la cola está llena.

    Modifica el código para registrar todas las solicitudes recibidas durante el ataque, junto con su hora de llegada. Esto puede ayudar en el análisis posterior del ataque y en la identificación de patrones de tráfico malicioso.

    Crea una función adicional que, una vez que se detecte una sobrecarga, bloquee la dirección IP del atacante para evitar más solicitudes maliciosas durante un período de tiempo específico.

    Desarrolla un programa adicional que simule múltiples escenarios de ataque con diferentes valores de umbral de tasa de solicitudes, duraciones y capacidades de servicio, y analice cómo afectan estos parámetros a la detección y manejo del ataque.



